:PROPERTIES:
:GPTEL_MODEL: gemini-3-pro-preview
:GPTEL_BACKEND: Gemini
:GPTEL_SYSTEM: 1. 간단하고 자세하게 설명하라. 2. 서술어를 사용하지 말라. 3.한국어를 사용하라(전문용어는 번역하지 말 것) 4. 추론과정을 보이지 말고 결과 내용만 말할 것.\n
:GPTEL_MAX_TOKENS: 500
:GPTEL_BOUNDS: ((response (521 7850)))
:END:

* Grpc 를 이용하여 아래와 같은 기능하는 예제 코드를 작성하라.
** 단계별로 실행 TODO를 작성하라
** 각 실행 TODO의 코드 작성 후 사용된 method 를 설명하라.
** Condition
- client
  1. 전송 데이터: jpg 파일1개, 파일 설명, 파일 작성자, 파일작성자의 전화번호
- server
  1. 전송 받은 파일을 ./received 경로에 저장
  2. 해당 파일과 같은 이름의 파일에 파일설명, 파일작성자, 작성자 전화번호 기록





#+begin_reasoning
**Analyzing gRPC Client Needs*

I've been assessing the requirements for a gRPC client example, specifically focusing on how to interact with an address book service. The existing codebase provides a solid foundation, guiding me to leverage =addressbook_pb2= for message definitions. I'm prioritizing clarity and efficiency in the generated client code. I'm now exploring best practices for error handling and connection management.


*Developing File Transfer Logic*

I'm now diving into the design of a gRPC interface for file transfer, naming the service =FileService=. My focus is on crafting a request message that incorporates image bytes and metadata strings. While chunking is a common practice for file transfers, a simpler approach, like sending the entire file as bytes or using a basic stream, seems more appropriate for this specific example's clarity requirements. I'll need to define the exact structure within the proto file.


*Simplifying File Uploads*

I've been thinking about the file transfer implementation. Considering the example's focus, I'm opting for a straightforward =FileUploadRequest= containing =bytes= for file content to keep things concise. I'm prioritizing clarity. The proto definition is as follows: =service FileTransfer { rpc Upload (FileUploadRequest) returns (FileUploadResponse); } message FileUploadRequest { string filename = 1; bytes file_data = 2; string description = 3; string author = 4; string phone_number = 5; } message FileUploadResponse { string message = 1; }=


*Outlining Client-Server Structure*

I'm making progress in outlining the client and server components for the file transfer example. The gRPC server will listen on a port and implement the =Upload= method. I'm focusing on handling the file bytes and metadata within the server. The client's functionality includes reading a local file, constructing the gRPC request, and calling the =Upload= service, using =grpc.insecure_channel=. I'll use the provided proto definitions.


*Implementing File Handling*

I'm now focusing on the server's file handling. I'm finalizing the structure, with =file_transfer.proto= as the protobuf definition. The server, in =file_server.py=, will listen on a port and implement the =Upload= method to handle file bytes. The client in =file_client.py= will read a file, create the gRPC request, and call the service. A dummy image file is needed for testing. The server will save the file to a =./received= directory, alongside its metadata.


*Constructing Server Components*

I'm now writing the server-side code. First, I'm importing the generated modules. Next, I'll flesh out the =Upload= implementation, including creating directories using =os.makedirs= and writing the binary and text data to files. Following this, I'll build the client, focusing on reading the file as binary, constructing the request and then sending it.

*Finalizing System Integration*

I've completed the server and client setup. I'm focusing on explanations of key methods now. Server-side, =add_FileTransferServicer_to_server= registers the service, and =server.start= runs it. The client connects using =grpc.insecure_channel= and invokes the RPC call via =stub.Upload=. I'll also be explaining the use of =open= for file I/O.



#+end_reasoning

*** 1. Proto 파일 정의 및 코드 생성

*TODO: 데이터 구조 및 서비스 정의*

=file_transfer.proto= 작성.

#+begin_src protobuf
syntax = "proto3";

package filetransfer;

// 서비스 정의
service FileTransfer {
  rpc Upload (FileUploadRequest) returns (FileUploadResponse) {}
}

// 요청 메시지: 파일 데이터 및 메타데이터 포함
message FileUploadRequest {
  string filename = 1;
  bytes file_data = 2;       // 이미지 바이너리
  string description = 3;    // 파일 설명
  string author = 4;         // 작성자
  string phone_number = 5;   // 전화번호
}

// 응답 메시지
message FileUploadResponse {
  string message = 1;
}
#+end_src

*사용 Method 설명:*
-   =service=: RPC 서비스 인터페이스 정의.
-   =rpc=: 원격 호출 메서드 정의 (Client -> Server).
-   =message=: 데이터 구조체 정의.
-   =bytes=: 이미지 등 바이너리 데이터 전송을 위한 자료형.

---

*TODO: Python 코드 생성*

터미널에서 실행.

#+begin_src bash
python -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. file_transfer.proto
#+end_src

*사용 Method 설명:*
-   =--python_out=: 메시지 클래스(=_pb2.py=) 생성 옵션.
-   =--grpc_python_out=: gRPC 서비스 스텁(=_pb2_grpc.py=) 생성 옵션.

---

*** 2. Server 코드 작성

*TODO: 파일 수신 및 저장 로직 구현*

=file_server.py= 작성.

#+begin_src python
import grpc
from concurrent import futures
import os
import file_transfer_pb2
import file_transfer_pb2_grpc

class FileTransferServicer(file_transfer_pb2_grpc.FileTransferServicer):
    def Upload(self, request, context):
        # 저장 경로 생성
        save_dir = './received'
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)

        # 1. 전송 받은 파일 저장 (Binary Write)
        file_path = os.path.join(save_dir, request.filename)
        with open(file_path, 'wb') as f:
            f.write(request.file_data)

        # 2. 메타데이터 텍스트 파일 저장
        meta_path = file_path + ".txt"
        with open(meta_path, 'w', encoding='utf-8') as f:
            f.write(f"Description: {request.description}\n")
            f.write(f"Author: {request.author}\n")
            f.write(f"Phone: {request.phone_number}\n")

        print(f"Saved: {request.filename}")
        return file_transfer_pb2.FileUploadResponse(message=f"Upload Success: {request.filename}")

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    file_transfer_pb2_grpc.add_FileTransferServicer_to_server(FileTransferServicer(), server)
    server.add_insecure_port('[::]:50051')
    print("Server started on port 50051")
    server.start()
    server.wait_for_termination()

if __name__ == '__main__':
    serve()
#+end_src

*사용 Method 설명:*
-   =os.makedirs=: 디렉토리 생성 (존재하지 않을 경우).
-   =open(..., 'wb')=: 파일을 바이너리 쓰기 모드로 열기 (이미지 저장용).
-   =open(..., 'w')=: 파일을 텍스트 쓰기 모드로 열기 (메타데이터 저장용).
-   =add_FileTransferServicer_to_server=: 구현한 Servicer 클래스를 gRPC 서버에 등록.
-   =server.add_insecure_port=: 보안 없는(Insecure) 통신 포트 개방.
-   =server.start=: 서버 가동 시작.

---

*** 3. Client 코드 작성

*TODO: 파일 읽기 및 전송 요청 구현*

=file_client.py= 작성.
(실행 전 같은 경로에 =sample.jpg= 파일 준비 필요)

#+begin_src python
import grpc
import file_transfer_pb2
import file_transfer_pb2_grpc

def run():
    target_file = "sample.jpg"

    # 전송할 파일 읽기
    try:
        with open(target_file, 'rb') as f:
            file_bytes = f.read()
    except FileNotFoundError:
        print(f"Error: {target_file} not found.")
        return

    # 서버 연결
    with grpc.insecure_channel('localhost:50051') as channel:
        stub = file_transfer_pb2_grpc.FileTransferStub(channel)

        # 요청 데이터 생성
        request = file_transfer_pb2.FileUploadRequest(
            filename=target_file,
            file_data=file_bytes,
            description="여행 사진입니다.",
            author="김철수",
            phone_number="010-9876-5432"
        )

        print(f"Sending file: {target_file}...")

        # 서버로 전송 (RPC 호출)
        response = stub.Upload(request)
        print(f"Server Response: {response.message}")

if __name__ == '__main__':
    run()
#+end_src

*사용 Method 설명:*
-   =open(..., 'rb')=: 로컬 이미지를 바이너리 읽기 모드로 열기.
-   =grpc.insecure_channel=: gRPC 채널 생성 (서버 주소 연결).
-   =FileTransferStub=: 클라이언트용 Stub 객체 생성.
-   =stub.Upload=: Proto 파일에 정의된 RPC 메서드 호출 (데이터 전송).

***
